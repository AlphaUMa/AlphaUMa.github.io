{"meta":{"title":"Alison's Space","subtitle":null,"description":null,"author":"Alison","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2017-07-20T06:32:03.728Z","updated":"2017-07-18T01:38:18.584Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-07-20T06:32:03.732Z","updated":"2017-07-18T01:38:18.583Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-08-18T12:23:37.985Z","updated":"2017-08-18T12:23:37.985Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我是个程序员"}],"posts":[{"title":"背包问题","slug":"alg_pack","date":"2017-11-02T07:24:39.198Z","updated":"2017-11-02T07:59:48.264Z","comments":true,"path":"2017/11/02/alg_pack/","link":"","permalink":"http://yoursite.com/2017/11/02/alg_pack/","excerpt":"","text":"01背包（ZeroOnePack）有N件物品和一个容量为W的背包。（每种物品均只有一件）第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。 完全背包(CompletePack)有N种物品和一个容量为W的背包，每种物品都有无限件可用。第i种物品的费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 多重背包(MultiplePack)有N种物品和一个容量为W背包。第i种物品最多有n[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 一要注意每个循环的取值范围二要注意每个循环的循环方向01背包递推式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]) 二维数组，正向，时间O(NW),空间O(NW) 123456789101112for (int j = 0; j &lt;= W; ++j) &#123; dp[0][j] = 0;&#125;for (int i = 1; i &lt; N; ++i) &#123; for (int j = 0; j &lt;= W; ++j) &#123; if (j &lt; w[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]) &#125;&#125; 优化空间复杂度——一维数组，外循环正向，内循环逆向，时间O(NW),空间O(W) 123456for (int i = 0; i &lt; N; ++i) &#123; for (int j = W; j &gt;= w[i]; --j) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125;&#125; Note: 为啥是逆向？要保证在推dp[i][j]时，能够取用dp[i - 1][j]和dp[i - 1][j - w[i]],看图，只有当j从右向左更新的时候，更新到dp[j]时才能取用到原来的dp[j]和dp[j-w[i]]. 123 j-w[i] j i-1 ● ●i ☆ ☆表示要求的状态，●表示求☆状态需要的状态 完全背包这个问题有三种优化方式，（参考背包九讲）现在只选第三种O(NW)的算法其实就是对第i件物品放入多少进行讨论，分两种就好了，一件都不放！放一件以上！于是：递推式：dp[i][j]=max(dp[i-1][j],dp[i][j-c[i]]+w[i])，内外循环都是正向！其中， dp[i-1][j]——一件都没放 dp[i][j-w[i]]+v[i]——至少放了一件一维数组代码如下，它跟01背包问题的代码只有内循环方向相反而已！！123 j-w[i] j i-1 ●i ● ☆ 12345for (int i = 0; i &lt; N; ++i) &#123; for (int j = w[i]; j &lt;= W; ++j) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125;&#125; Note: 关于滚动降维后的循环方向问题，看递推式，像上面一样画图表示后就一目了然！ 多重背包递推式见“背包九讲”多重背包好像较多用于判断可行性（POJ 1742）","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://yoursite.com/categories/算法和数据结构/"}],"tags":[]},{"title":"常用的几个code snippet","slug":"alg_1","date":"2017-11-02T07:21:39.404Z","updated":"2017-11-02T07:45:48.317Z","comments":true,"path":"2017/11/02/alg_1/","link":"","permalink":"http://yoursite.com/2017/11/02/alg_1/","excerpt":"","text":"进制转换123456789//将x转为n进制static String convert(int x, int n) &#123; StringBuilder sb = new StringBuilder(); while (x &gt; 0) &#123; sb.insert(0, x % n); x /= n; &#125; return sb.toString(); &#125; 求素数（求素数.md）计算两个整数a,b的最大公约数（欧几里德算法）1234int gcd(int a,int b)&#123; if(b==0)return a; return gcd(b,a%b);&#125; 在已知a, b求解一组x，y使得ax+by = gcd(a, b) =d(扩展欧几里德算法)1234567891011int exGcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1;y=0; return a; &#125; int r=exGcd(b,a%b,x,y); int t=x;x=y;y=t-a/b*y; return r;&#125; 试除法 123456789int is_prime(int n) &#123; int i; if (n&lt;=1) return 0; //n不是素数，返回零 for(i=2; i*i&lt;=n; i++) //for(int i = 2; i &lt;= sqrt(n); ++i) &#123; if( n%i==0 ) return 0; //判断n能否被i整除 &#125; return 1; &#125; 筛法(Eratosthenes) 123456789//筛选法求1000以内素数（删除所有素数的倍数） vector&lt;int&gt; v(1000,1); for(int i=2;i&lt;1000;++i)&#123; for(int j=2;i*j&lt;1000;++j)&#123; if(v[i])&#123; v[i*j]=0; &#125; &#125; &#125; 快速幂运算12345678910typedef long long ll;ll mod_pow(ll x, ll n, ll mod) &#123;ll res = 1;while (n) &#123;if (n &amp; 1)res = res * x % mod;x = x * x % mod;n &gt;&gt; 1;&#125;return res;&#125; 统计后面小于自己的个数也就是 315. Count of Smaller Numbers After Self此题还能用线段树解，但是代码太多，直接二分法吧。123456789101112131415161718192021222324252627public List&lt;Integer&gt; countSmaller(int[] nums) &#123; Integer[] ans = new Integer[nums.length]; List&lt;Integer&gt; sorted = new ArrayList&lt;Integer&gt;(); for (int i = nums.length - 1; i &gt;= 0; i--) &#123; int index = findIndex(sorted, nums[i]); ans[i] = index; sorted.add(index, nums[i]); &#125; return Arrays.asList(ans); &#125; private int findIndex(List&lt;Integer&gt; sorted, int target) &#123; if (sorted.size() == 0) return 0; int start = 0; int end = sorted.size() - 1; if (sorted.get(end) &lt; target) return end + 1; if (sorted.get(start) &gt;= target) return 0; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (sorted.get(mid) &lt; target) &#123; start = mid + 1; &#125; else &#123; end = mid; &#125; &#125; if (sorted.get(start) &gt;= target) return start; return end; &#125; 最长递增序列（LIS) （不采用）基础解法，O(n^2), TLEdp[i]=以ai为末尾的最长上升子序列的长度转移式：`dp[i]=max(dp[i],dp[j]+1) j&lt;i 优化解法，O(n*logn)dp[i]=长度为i+1的上升子序列中末尾元素的最小值 Java812345678910111213141516171819202122232425262728public int lengthOfLIS(int[] nums) &#123; if(nums==null || nums.length==0) return 0; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int num: nums)&#123; if(list.size()==0 || num&gt;list.get(list.size()-1))&#123; list.add(num); &#125;else&#123; int i=0; int j=list.size()-1; while(i&lt;j)&#123; int mid = (i+j)/2; if(list.get(mid) &lt; num)&#123; i=mid+1; &#125;else&#123; j=mid; &#125; &#125; list.set(j, num); &#125; &#125; return list.size();&#125; C++1234567int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ans; for (int a : nums) if (ans.size() == 0 || a &gt; ans.back()) ans.push_back(a); else *lower_bound(ans.begin(), ans.end(), a) = a; return ans.size();&#125; 最长公共子序列(LCS)12345678910111213public int longestCommonSubsequence(String A, String B) &#123; int n = A.length(); int m = B.length(); int f[][] = new int[n + 1][m + 1]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]); if(A.charAt(i - 1) == B.charAt(j - 1)) f[i][j] = f[i - 1][j - 1] + 1; &#125; &#125; return f[n][m]; &#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://yoursite.com/categories/算法和数据结构/"}],"tags":[]},{"title":"人脸变形常用方法","slug":"image_warp_1","date":"2017-11-02T05:53:11.636Z","updated":"2017-11-02T08:19:19.745Z","comments":true,"path":"2017/11/02/image_warp_1/","link":"","permalink":"http://yoursite.com/2017/11/02/image_warp_1/","excerpt":"","text":"实验室接的项目，客户是某大型婚纱摄影公司。要求把刚拍好的婚纱照尽量美化，节省百分之八十的美工工作。我负责人脸变形部分，调整脸型和五官。调研一番后，发现很多APP都已经实现了实时瘦脸和大眼两个功能，用的算法就两种，调整形状用图像局部扭曲算法，放大用图像局部放大算法。 图像局部扭曲算法 图像局部扭曲其实就是PS中的“液化”效果，又称为前倾变形。 这种变形算法我参考了这篇博客 但是其中只给了简要的步骤，并没有讲明具体的插值办法，所以自己用双线性插值法写了个完整的算法，主要插值代码如下： 1234567891011121314151617181920212223242526272829 for j = Top : Bottom for i = Left : Right dy = j - Cy; dx = i - Cx; PC2 = dx * dx + dy * dy; if PC2 &lt;= r2 k=(r2-PC2)/(r2-PC2+MC2); k2=k*k; x=i-k2*MCx; y=j-k2*MCy; x=max(x,1); x=min(x,w-1); y=max(y,1); y=min(y,h-1); x1=floor(x); x2=x1+1; y1=floor(y); y2=y1+1; tt1=(x2-x)*J(y1,x1,:)+(x-x1)*J(y1,x2,:); tt2=(x2-x)*J(y2,x1,:)+(x-x1)*J(y2,x2,:); tt=(y2-y)*tt1+(y-y1)*tt2; J(j,i,:)=tt; end endend 图像局部放大算法","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://yoursite.com/categories/图像处理/"}],"tags":[]},{"title":"二叉搜索树的后序遍历序列","slug":"jzoffer_18","date":"2017-08-18T12:33:33.030Z","updated":"2017-08-19T14:10:08.601Z","comments":true,"path":"2017/08/18/jzoffer_18/","link":"","permalink":"http://yoursite.com/2017/08/18/jzoffer_18/","excerpt":"","text":"题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 题解参考牛客网答案BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。 Solution123456789101112131415161718public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length==0)return false; return check(sequence,0,sequence.length-1); &#125; boolean check(int [] s,int l,int r)&#123; if(l&gt;=r)return true; int i=r; while(i&gt;l &amp;&amp; s[i-1]&gt;s[r])i--; for(int j=i-1;j&gt;=l;j--)&#123; if(s[j]&gt;s[r]) return false; &#125; return check(s,l,i-1) &amp;&amp; check(s,i,r-1); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"TreeNode","slug":"TreeNode","permalink":"http://yoursite.com/tags/TreeNode/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"二叉树的镜像","slug":"jzoffer_17","date":"2017-08-18T12:25:52.553Z","updated":"2017-08-18T12:33:21.783Z","comments":true,"path":"2017/08/18/jzoffer_17/","link":"","permalink":"http://yoursite.com/2017/08/18/jzoffer_17/","excerpt":"","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:二叉树的镜像定义：源二叉树1234567891011 8 / \\ 6 10 / \\ / \\5 7 9 11镜像二叉树 8 / \\ 10 6 / \\ / \\11 9 7 5 Solution1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null)return; TreeNode tmp=root.left; root.left=root.right; root.right=tmp; Mirror(root.left); Mirror(root.right); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"TreeNode","slug":"TreeNode","permalink":"http://yoursite.com/tags/TreeNode/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"HasSubtree","slug":"jzoffer_16","date":"2017-08-18T12:24:16.644Z","updated":"2017-08-18T12:32:44.973Z","comments":true,"path":"2017/08/18/jzoffer_16/","link":"","permalink":"http://yoursite.com/2017/08/18/jzoffer_16/","excerpt":"","text":"题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） Solution1234567891011121314public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root1==null || root2==null)return false; return isEqual(root1,root2)||HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2); &#125; public boolean isEqual(TreeNode r1,TreeNode r2)&#123; if(r2==null)return true; if(r1==null)return false; return r1.val==r2.val &amp;&amp; isEqual(r1.left,r2.left) &amp;&amp; isEqual(r1.right,r2.right); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"TreeNode","slug":"TreeNode","permalink":"http://yoursite.com/tags/TreeNode/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"花花使用总结","slug":"honor_2","date":"2017-08-02T07:44:58.289Z","updated":"2017-08-02T08:09:14.794Z","comments":true,"path":"2017/08/02/honor_2/","link":"","permalink":"http://yoursite.com/2017/08/02/honor_2/","excerpt":"","text":"上单 反红开局不点技能，蹲草丛，36’左右去敌红，如果顺利，点2技能扔红，不顺利一技能逃跑。 gank不要急着收小兵，利用地方兵线作为跳板， 轻剑1技能贴近，平A加2技能打出沉默，逃跑的话，再1技能追上，切大招推人 打野我发现打野gank成功率比上单高 重剑连招轻剑3转重剑——A——2——1——A——1","categories":[{"name":"农药","slug":"农药","permalink":"http://yoursite.com/categories/农药/"}],"tags":[{"name":"花木兰","slug":"花木兰","permalink":"http://yoursite.com/tags/花木兰/"}]},{"title":"反转链表","slug":"jzoffer_15","date":"2017-07-21T08:23:05.883Z","updated":"2017-08-18T12:24:05.801Z","comments":true,"path":"2017/07/21/jzoffer_15/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_15/","excerpt":"","text":"Recursion12345678910public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null || head.next==null)return head; ListNode pre=ReverseList(head.next); head.next.next=head; head.next=null; return pre; &#125;&#125; Iterationwhile里面就做一件事，把所有向右的箭头全部变成向左123456789101112131415161718public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null || head.next==null)return head; ListNode rHead=null,cur=head,pre=null; while(cur.next!=null)&#123; ListNode tmp=cur.next; cur.next=pre; pre=cur; cur=tmp; &#125; rHead=cur; cur.next=pre; return rHead; &#125;&#125;`","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"},{"name":"reverse","slug":"reverse","permalink":"http://yoursite.com/tags/reverse/"}]},{"title":"链表中倒数第k个结点","slug":"jzoffer_14","date":"2017-07-21T06:59:53.682Z","updated":"2017-08-02T08:07:11.806Z","comments":true,"path":"2017/07/21/jzoffer_14/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_14/","excerpt":"","text":"题目描述输入一个链表，输出该链表中倒数第k个结点。 分析双指针，fast,slow Solution12345678910111213141516171819public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode fast=head,slow=head; while(k&gt;0 &amp;&amp; fast!=null)&#123; fast=fast.next; k--; &#125; if(k&gt;0)return null; while(fast!=null)&#123; fast=fast.next; slow=slow.next; &#125; return slow; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://yoursite.com/tags/two-pointers/"}]},{"title":"调整数组顺序使奇数位于偶数前面","slug":"jzoffer_13","date":"2017-07-21T06:57:22.827Z","updated":"2017-08-02T08:07:16.885Z","comments":true,"path":"2017/07/21/jzoffer_13/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_13/","excerpt":"","text":"题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 分析 首先会想到双指针遇到奇数偶数就交换，即quick-sort，但是会改变相对位置 然后想到冒泡排序，依次把偶数排到后面去，要n平方的时间复杂度，舍弃。 最后发现其实啥算法都不用，如下： 1234567891011121314151617181920import java.util.*;public class Solution &#123; public void reOrderArray(int [] array) &#123; Stack s=new Stack(); for(int i:array)&#123; if(i%2&gt;0)&#123; s.push(i); &#125; &#125; for(int i:array)&#123; if(i%2==0)&#123; s.push(i); &#125; &#125; for(int i=array.length-1;i&gt;=0;i--)&#123; array[i]=(int)s.pop(); &#125; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"数值的整数次方","slug":"jzoffer_12","date":"2017-07-21T06:36:43.709Z","updated":"2017-08-02T08:07:19.351Z","comments":true,"path":"2017/07/21/jzoffer_12/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_12/","excerpt":"","text":"题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 分析原理同快速幂运算 Solution123456789101112public class Solution &#123; public double Power(double base, int exponent) &#123; int e=Math.abs(exponent); double r=1; while(e&gt;0)&#123; if((e&amp;1)&gt;0)r*=base; base*=base; e&gt;&gt;=1; &#125; return (exponent&gt;=0)?r:1/r; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"bit manipulation","slug":"bit-manipulation","permalink":"http://yoursite.com/tags/bit-manipulation/"}]},{"title":"二进制中1的个数","slug":"jzoffer_11","date":"2017-07-21T06:03:49.215Z","updated":"2017-08-02T08:07:22.209Z","comments":true,"path":"2017/07/21/jzoffer_11/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_11/","excerpt":"","text":"题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示 分析n&amp;(n-1)可以去掉最右的1，不停地去掉1，直至为0 Solution12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int cnt=0; while(n!=0)&#123; n&amp;=n-1; //remove rightmost 1 cnt++; &#125; return cnt; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"bit manipulation","slug":"bit-manipulation","permalink":"http://yoursite.com/tags/bit-manipulation/"}]},{"title":"矩形覆盖","slug":"jzoffer_10","date":"2017-07-21T05:53:41.883Z","updated":"2017-08-02T08:06:54.207Z","comments":true,"path":"2017/07/21/jzoffer_10/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_10/","excerpt":"","text":"题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 分析看到这种“多少种方法”，要么是用backtracking来穷举，要么是用dp。拒绝穷举，于是思考dp。首先因为长方形是2X1的，所以不管怎么摆，一个4x4的格子只可能有2种摆法，一个2X1格子只可能有1种摆法。考虑第n行，要么是先摆好n-1，然后最后横着放个2*1，要么是先摆好n-2，然后竖着放两个2*1所以有 dp[i]=dp[i-1]+dp[i-2] Soltion123456789101112public class Solution &#123; public int RectCover(int target) &#123; if(target&lt;=2)return target; int p1=1,p2=2; while(target--&gt;2)&#123; int cur=p1+p2; p1=p2; p2=cur; &#125; return p2; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"变态跳台阶","slug":"jzoffer_9","date":"2017-07-21T02:52:53.244Z","updated":"2017-08-31T06:00:43.351Z","comments":true,"path":"2017/07/21/jzoffer_9/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_9/","excerpt":"","text":"题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 分析最BF的方法肯定是dp,对每个dp[i],将i之前所有的dp[j]累加,这样复杂度为n平方,想都不用想肯定TLE了然而仔细一想由dp[i]=∑dp[j](j&lt;i)，直接得到dp[i]=2*dp[i-1]，于是复杂度降为n Solution123456789101112131415public class Solution &#123; public int JumpFloorII(int target) &#123; int n=target; int[] dp=new int[n+1]; for(int i=0;i&lt;=n;i++)&#123; if(i&lt;=2)&#123; dp[i]=i; continue; &#125; dp[i]=dp[i-1]*2; &#125; return dp[n]; &#125;&#125; 进一步节省空间，去掉dp数组1234567891011public class Solution &#123; public int JumpFloorII(int target) &#123; int n=target; if(target&lt;=2)return target; int p=2; while(target--&gt;2)&#123; p*=2; &#125; return p; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"跳台阶","slug":"jzoffer_8","date":"2017-07-21T02:36:38.770Z","updated":"2017-08-31T06:00:03.746Z","comments":true,"path":"2017/07/21/jzoffer_8/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_8/","excerpt":"","text":"题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 Solution123456789101112public class Solution &#123; public int JumpFloor(int target) &#123; if(target&lt;=2)return target; int p1=1,p2=2; while(target--&gt;2)&#123; int cur=p1+p2; p1=p2; p2=cur; &#125; return p2; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"斐波那契数列","slug":"jzoffer_7","date":"2017-07-21T02:24:53.906Z","updated":"2017-08-02T08:06:36.433Z","comments":true,"path":"2017/07/21/jzoffer_7/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_7/","excerpt":"","text":"题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 分析 递归不好，n超大的时候溢出 用节省空间版dp Solution123456789101112public class Solution &#123; public int Fibonacci(int n) &#123; int pre1=0,pre2=1; if(n&lt;=1)return n; while(n--&gt;=2)&#123; int tmp=pre2; pre2=pre1+pre2; pre1=tmp; &#125; return pre2; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"旋转数组的最小数字","slug":"jzoffer_6","date":"2017-07-21T02:13:28.539Z","updated":"2017-08-02T08:06:25.066Z","comments":true,"path":"2017/07/21/jzoffer_6/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_6/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 Find Minimum in Rotated Sorted Array II(Hard,有重复数字) Solution12345678910111213141516import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int l=0,r=array.length-1; while(l&lt;r)&#123; int mid=l+((r-l)&gt;&gt;1); if(array[mid]&lt;array[r]) r=mid; else if(array[mid]&gt;array[r]) l=mid+1; else r--; &#125; return array[l]; &#125;&#125; 相关 Find Minimum in Rotated Sorted Array(无重复数字)12345678910111213public class Solution &#123; public int findMin(int[] nums) &#123; int l=0,r=nums.length-1; while(l&lt;r)&#123; int mid=(l+r)/2; if(nums[mid]&gt;nums[r]) l=mid+1; else r=mid; &#125; return nums[l]; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"},{"name":"rotate array","slug":"rotate-array","permalink":"http://yoursite.com/tags/rotate-array/"},{"name":"binary search","slug":"binary-search","permalink":"http://yoursite.com/tags/binary-search/"}]},{"title":"用两个栈实现队列","slug":"jzoffer_5","date":"2017-07-20T09:00:38.590Z","updated":"2017-08-02T08:06:26.011Z","comments":true,"path":"2017/07/20/jzoffer_5/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_5/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。LC:232. Implement Queue using Stacks 思路s2用来顺序存放所有元素，s1用来缓存每次存入新的node时，先将s2中的元素倒出到s1，即变为逆序了，然后再把新node压入s2，然后再把s1中的元素倒入s2 Solution123456789101112131415161718192021import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; while(!stack2.isEmpty())&#123; stack1.push(stack2.pop()); &#125; stack2.push(node);//或者stack1.push(node)，想想为啥 while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; public int pop() &#123; return stack2.pop(); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"queue","slug":"queue","permalink":"http://yoursite.com/tags/queue/"}]},{"title":"重建二叉树","slug":"jzoffer_4","date":"2017-07-20T08:45:12.987Z","updated":"2017-08-02T08:06:26.760Z","comments":true,"path":"2017/07/20/jzoffer_4/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_4/","excerpt":"","text":"题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。其实就是 LC105.Construct Binary Tree from Preorder and Inorder Traversal Solution1234567891011121314151617181920212223public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return build(pre,0,pre.length-1,in,0,in.length-1); &#125; TreeNode build(int [] pre,int ps,int pe,int [] in,int is ,int ie)&#123; if(ps&gt;pe||is&gt;ie || pe&gt;=pre.length || ie&gt;=in.length)return null; int r=0;//index of root in in[] //find root for(int i=is;i&lt;=ie;i++)&#123; if(in[i]==pre[ps])&#123; r=i; break; &#125; &#125; int d=r-is;// length of left part TreeNode root=new TreeNode(in[r]); root.left=build(pre,ps+1,ps+d,in,is,r-1); root.right=build(pre,ps+d+1,pe,in,r+1,ie); return root; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://yoursite.com/tags/tree/"},{"name":"binary tree","slug":"binary-tree","permalink":"http://yoursite.com/tags/binary-tree/"}]},{"title":"从尾到头打印链表","slug":"jzoffer_3","date":"2017-07-20T08:10:45.669Z","updated":"2017-08-02T08:06:27.984Z","comments":true,"path":"2017/07/20/jzoffer_3/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_3/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 Solution 1 Stack1234567891011121314151617import java.util.*;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack s=new Stack(); ListNode cur=listNode; while(cur!=null)&#123; s.push(cur.val); cur=cur.next; &#125; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); while(!s.isEmpty())&#123; res.add((int)s.pop()); &#125; return res; &#125;&#125; Soluton 2 Recursion12345678910111213import java.util.*;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(listNode ==null)return res; ListNode p=listNode; if(p.next!= null) res=printListFromTailToHead(p.next); res.add(p.val); return res; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"}]},{"title":"二维数组中的查找","slug":"jzoffer_1","date":"2017-07-20T07:35:22.877Z","updated":"2017-08-02T08:03:59.721Z","comments":true,"path":"2017/07/20/jzoffer_1/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_1/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 Solution123456789101112131415public class Solution &#123; public boolean Find(int target, int [][] a) &#123; if(a==null || a.length==0)return false; int m=a.length,n=a[0].length; int i=0,j=n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(a[i][j]==target)return true; else if(target&gt;a[i][j]) i++; else j--; &#125; return false; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"}]},{"title":"IOS基础","slug":"ios_1","date":"2017-07-20T06:52:08.484Z","updated":"2017-07-20T06:52:09.139Z","comments":true,"path":"2017/07/20/ios_1/","link":"","permalink":"http://yoursite.com/2017/07/20/ios_1/","excerpt":"","text":"","categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/tags/IOS/"}]},{"title":"七月中旬随笔","slug":"honor_1","date":"2017-07-20T02:19:47.089Z","updated":"2017-07-20T02:19:47.127Z","comments":true,"path":"2017/07/20/honor_1/","link":"","permalink":"http://yoursite.com/2017/07/20/honor_1/","excerpt":"","text":"","categories":[{"name":"农药","slug":"农药","permalink":"http://yoursite.com/categories/农药/"}],"tags":[]},{"title":"10. Regular Expression Matching","slug":"LC_10","date":"2017-07-20T02:17:22.603Z","updated":"2017-07-20T05:19:05.293Z","comments":true,"path":"2017/07/20/LC_10/","link":"","permalink":"http://yoursite.com/2017/07/20/LC_10/","excerpt":"","text":"ProblemImplement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.​12345678910111213141516​'.' Matches any single character.'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(\"aa\",\"a\") → falseisMatch(\"aa\",\"aa\") → trueisMatch(\"aaa\",\"aa\") → falseisMatch(\"aa\", \"a*\") → trueisMatch(\"aa\", \".*\") → trueisMatch(\"ab\", \".*\") → trueisMatch(\"aab\", \"c*a*b\") → true My Solution1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int j = 2; j &lt;= n; j++) &#123; if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (p.charAt(j - 1) == '*') dp[i][j] = dp[i][j - 1] || (j &gt;= 2 &amp;&amp; dp[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) || (j &gt; 2 &amp;&amp; dp[i][j - 2]); else if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; return dp[m][n];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"替换空格","slug":"jzoffer_2","date":"2017-07-20T02:08:43.622Z","updated":"2017-08-02T08:04:07.431Z","comments":true,"path":"2017/07/20/jzoffer_2/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_2/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 Solution12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(\"\\\\s\",\"%20\"); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}]},{"title":"CNN初探","slug":"paper_1","date":"2017-07-20T02:05:23.411Z","updated":"2017-11-02T05:52:28.363Z","comments":true,"path":"2017/07/20/paper_1/","link":"","permalink":"http://yoursite.com/2017/07/20/paper_1/","excerpt":"","text":"","categories":[{"name":"图像理解","slug":"图像理解","permalink":"http://yoursite.com/categories/图像理解/"}],"tags":[]},{"title":"Round D Problem A. Go Sightseeing","slug":"kk_d_a","date":"2017-07-20T01:57:33.331Z","updated":"2017-07-20T02:24:11.595Z","comments":true,"path":"2017/07/20/kk_d_a/","link":"","permalink":"http://yoursite.com/2017/07/20/kk_d_a/","excerpt":"","text":"ProblemWhen you travel, you like to spend time sightseeing in as many cities as possible, but sometimes you might not be able to because you need to catch the bus to the next city. To maximize your travel enjoyment, you decide to write a program to optimize your schedule. You begin at city 1 at time 0 and plan to travel to cities 2 to N in ascending order, visiting every city. There is a bus service from every city i to the next city i + 1. The i-th bus service runs on a schedule that is specified by 3 integers: Si, Fi and Di, the start time, frequency and ride duration. Formally, this means that there is a bus leaving from city i at all times Si + xFi, where x is an integer and x ≥ 0, and the bus takes Di time to reach city i + 1. At each city between 1 and N - 1, inclusive, you can decide to spend Ts time sightseeing before waiting for the next bus, or you can immediately wait for the next bus. You cannot go sightseeing multiple times in the same city. You may assume that boarding and leaving buses takes no time. You must arrive at city N by time Tf at the latest. (Note that you cannot go sightseeing in city N, even if you arrive early. There’s nothing to see there!) What is the maximum number of cities you can go sightseeing in? InputThe input starts with one line containing one integer T, which is the number of test cases. T test cases follow. Each test case begins with a line containing 3 integers, N, Ts and Tf, representing the number of cities, the time taken for sightseeing in any city, and the latest time you can arrive in city N. This is followed by N - 1 lines. On the i-th line, there are 3 integers, Si, Fi and Di, indicating the start time, frequency, and duration of buses travelling from city i to city i + 1. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of cities you can go sightseeing in such that you can still arrive at city N by time Tf at the latest. If it is impossible to arrive at city N by time Tf, output Case #x: IMPOSSIBLE. Limits1 ≤ T ≤ 100.Small dataset 2 ≤ N ≤ 16.1 ≤ Si ≤ 5000.1 ≤ Fi ≤ 5000.1 ≤ Di ≤ 5000.1 ≤ Ts ≤ 5000.1 ≤ Tf ≤ 5000.Large dataset 2 ≤ N ≤ 2000.1 ≤ Si ≤ 109.1 ≤ Fi ≤ 109.1 ≤ Di ≤ 109.1 ≤ Ts ≤ 109.1 ≤ Tf ≤ 109. Sample12345678910111213141516171819202122232425Input 44 3 123 2 16 2 21 3 23 2 301 2 273 2 14 1 112 1 24 1 58 2 25 10 500014 27 3127 11 4430 8 202000 4000 3OutputCase #1: 2Case #2: 0Case #3: IMPOSSIBLECase #4: 4 Solution","categories":[{"name":"Kickstart","slug":"Kickstart","permalink":"http://yoursite.com/categories/Kickstart/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"待月随笔","slug":"daiyuesuibi","date":"2017-07-20T01:54:07.987Z","updated":"2017-07-20T01:54:08.189Z","comments":true,"path":"2017/07/20/daiyuesuibi/","link":"","permalink":"http://yoursite.com/2017/07/20/daiyuesuibi/","excerpt":"","text":"","categories":[{"name":"广播剧","slug":"广播剧","permalink":"http://yoursite.com/categories/广播剧/"}],"tags":[{"name":"个人YY","slug":"个人YY","permalink":"http://yoursite.com/tags/个人YY/"}]},{"title":"POJ 3258 River Hopscotch","slug":"poj_3258","date":"2017-07-19T17:12:07.315Z","updated":"2017-07-18T02:39:20.408Z","comments":true,"path":"2017/07/20/poj_3258/","link":"","permalink":"http://yoursite.com/2017/07/20/poj_3258/","excerpt":"","text":"题意POJ 3258: River Hopscotch从N块石头中移除M块，使得间距最小值最大。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;//const int INF = 1000000010;int n, l, m;int d[50010];bool C(int x) &#123; int last = 0; for (int i = 1; i &lt; n - m; i++) &#123; int cur = last + 1; while (cur &lt; n &amp;&amp; d[cur] - d[last] &lt; x) &#123; cur++; &#125; if (cur == n )return false; last = cur; &#125; return true;&#125;void solve() &#123; sort(d, d + n ); int lb = 0, ub = l + 1; while (ub - lb &gt; 1) &#123; int mid = lb + ((ub - lb) &gt;&gt; 1); if (C(mid)) lb = mid; else ub = mid; //cout &lt;&lt; \"lb= \" &lt;&lt; lb &lt;&lt; \" ub=\" &lt;&lt; ub &lt;&lt; endl; &#125; cout &lt;&lt; lb &lt;&lt; endl;&#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); cin &gt;&gt; l &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; d[0] = 0; //起点 d[n + 1] = l; //终点 n++; n++; solve();&#125;","categories":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/categories/POJ/"}],"tags":[{"name":"最大化最小值","slug":"最大化最小值","permalink":"http://yoursite.com/tags/最大化最小值/"},{"name":"二分法","slug":"二分法","permalink":"http://yoursite.com/tags/二分法/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]}]}