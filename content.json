{"meta":{"title":"Alison's Space","subtitle":null,"description":null,"author":"Alison","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2017-07-20T01:27:17.341Z","updated":"2017-07-18T01:38:18.583Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-07-20T01:27:18.404Z","updated":"2017-07-18T01:38:18.584Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-07-20T01:27:17.793Z","updated":"2017-07-18T01:38:18.583Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"重建二叉树","slug":"jzoffer_4","date":"2017-07-20T08:45:12.987Z","updated":"2017-07-20T08:45:18.428Z","comments":true,"path":"2017/07/20/jzoffer_4/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_4/","excerpt":"","text":"题目描述题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。其实就是LC105. Construct Binary Tree from Preorder and Inorder Traversal Solution1234567891011121314151617181920212223public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return build(pre,0,pre.length-1,in,0,in.length-1); &#125; TreeNode build(int [] pre,int ps,int pe,int [] in,int is ,int ie)&#123; if(ps&gt;pe||is&gt;ie || pe&gt;=pre.length || ie&gt;=in.length)return null; int r=0;//index of root in in[] //find root for(int i=is;i&lt;=ie;i++)&#123; if(in[i]==pre[ps])&#123; r=i; break; &#125; &#125; int d=r-is;// length of left part TreeNode root=new TreeNode(in[r]); root.left=build(pre,ps+1,ps+d,in,is,r-1); root.right=build(pre,ps+d+1,pe,in,r+1,ie); return root; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://yoursite.com/categories/剑指Offer/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://yoursite.com/tags/tree/"},{"name":"binary tree","slug":"binary-tree","permalink":"http://yoursite.com/tags/binary-tree/"}]},{"title":"从尾到头打印链表","slug":"jzoffer_3","date":"2017-07-20T08:10:45.669Z","updated":"2017-07-20T08:10:46.310Z","comments":true,"path":"2017/07/20/jzoffer_3/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_3/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 Solution 1 Stack1234567891011121314151617import java.util.*;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack s=new Stack(); ListNode cur=listNode; while(cur!=null)&#123; s.push(cur.val); cur=cur.next; &#125; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); while(!s.isEmpty())&#123; res.add((int)s.pop()); &#125; return res; &#125;&#125; Soluton 2 Recursion12345678910111213import java.util.*;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(listNode ==null)return res; ListNode p=listNode; if(p.next!= null) res=printListFromTailToHead(p.next); res.add(p.val); return res; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://yoursite.com/categories/剑指Offer/"}],"tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"}]},{"title":"二维数组中的查找","slug":"jzoffer_1","date":"2017-07-20T07:35:22.877Z","updated":"2017-07-20T07:39:33.390Z","comments":true,"path":"2017/07/20/jzoffer_1/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_1/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 Solution123456789101112131415public class Solution &#123; public boolean Find(int target, int [][] a) &#123; if(a==null || a.length==0)return false; int m=a.length,n=a[0].length; int i=0,j=n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(a[i][j]==target)return true; else if(target&gt;a[i][j]) i++; else j--; &#125; return false; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://yoursite.com/categories/剑指Offer/"}],"tags":[{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"}]},{"title":"IOS基础","slug":"ios_1","date":"2017-07-20T06:52:08.484Z","updated":"2017-07-20T06:52:09.139Z","comments":true,"path":"2017/07/20/ios_1/","link":"","permalink":"http://yoursite.com/2017/07/20/ios_1/","excerpt":"","text":"","categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/tags/IOS/"}]},{"title":"七月中旬随笔","slug":"honor_1","date":"2017-07-20T02:19:47.089Z","updated":"2017-07-20T02:19:47.127Z","comments":true,"path":"2017/07/20/honor_1/","link":"","permalink":"http://yoursite.com/2017/07/20/honor_1/","excerpt":"","text":"","categories":[{"name":"农药","slug":"农药","permalink":"http://yoursite.com/categories/农药/"}],"tags":[]},{"title":"10. Regular Expression Matching","slug":"LC_10","date":"2017-07-20T02:17:22.603Z","updated":"2017-07-20T05:19:05.293Z","comments":true,"path":"2017/07/20/LC_10/","link":"","permalink":"http://yoursite.com/2017/07/20/LC_10/","excerpt":"","text":"ProblemImplement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.​12345678910111213141516​'.' Matches any single character.'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(\"aa\",\"a\") → falseisMatch(\"aa\",\"aa\") → trueisMatch(\"aaa\",\"aa\") → falseisMatch(\"aa\", \"a*\") → trueisMatch(\"aa\", \".*\") → trueisMatch(\"ab\", \".*\") → trueisMatch(\"aab\", \"c*a*b\") → true My Solution1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int j = 2; j &lt;= n; j++) &#123; if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (p.charAt(j - 1) == '*') dp[i][j] = dp[i][j - 1] || (j &gt;= 2 &amp;&amp; dp[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) || (j &gt; 2 &amp;&amp; dp[i][j - 2]); else if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; return dp[m][n];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"替换空格","slug":"jzoffer_2","date":"2017-07-20T02:08:43.622Z","updated":"2017-07-20T07:44:57.698Z","comments":true,"path":"2017/07/20/jzoffer_2/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_2/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 Solution12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(\"\\\\s\",\"%20\"); &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://yoursite.com/categories/剑指Offer/"}],"tags":[{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}]},{"title":"入门一","slug":"paper_1","date":"2017-07-20T02:05:23.411Z","updated":"2017-07-20T02:05:24.030Z","comments":true,"path":"2017/07/20/paper_1/","link":"","permalink":"http://yoursite.com/2017/07/20/paper_1/","excerpt":"","text":"","categories":[{"name":"图像理解","slug":"图像理解","permalink":"http://yoursite.com/categories/图像理解/"}],"tags":[]},{"title":"Round D Problem A. Go Sightseeing","slug":"kk_d_a","date":"2017-07-20T01:57:33.331Z","updated":"2017-07-20T02:24:11.595Z","comments":true,"path":"2017/07/20/kk_d_a/","link":"","permalink":"http://yoursite.com/2017/07/20/kk_d_a/","excerpt":"","text":"ProblemWhen you travel, you like to spend time sightseeing in as many cities as possible, but sometimes you might not be able to because you need to catch the bus to the next city. To maximize your travel enjoyment, you decide to write a program to optimize your schedule. You begin at city 1 at time 0 and plan to travel to cities 2 to N in ascending order, visiting every city. There is a bus service from every city i to the next city i + 1. The i-th bus service runs on a schedule that is specified by 3 integers: Si, Fi and Di, the start time, frequency and ride duration. Formally, this means that there is a bus leaving from city i at all times Si + xFi, where x is an integer and x ≥ 0, and the bus takes Di time to reach city i + 1. At each city between 1 and N - 1, inclusive, you can decide to spend Ts time sightseeing before waiting for the next bus, or you can immediately wait for the next bus. You cannot go sightseeing multiple times in the same city. You may assume that boarding and leaving buses takes no time. You must arrive at city N by time Tf at the latest. (Note that you cannot go sightseeing in city N, even if you arrive early. There’s nothing to see there!) What is the maximum number of cities you can go sightseeing in? InputThe input starts with one line containing one integer T, which is the number of test cases. T test cases follow. Each test case begins with a line containing 3 integers, N, Ts and Tf, representing the number of cities, the time taken for sightseeing in any city, and the latest time you can arrive in city N. This is followed by N - 1 lines. On the i-th line, there are 3 integers, Si, Fi and Di, indicating the start time, frequency, and duration of buses travelling from city i to city i + 1. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of cities you can go sightseeing in such that you can still arrive at city N by time Tf at the latest. If it is impossible to arrive at city N by time Tf, output Case #x: IMPOSSIBLE. Limits1 ≤ T ≤ 100.Small dataset 2 ≤ N ≤ 16.1 ≤ Si ≤ 5000.1 ≤ Fi ≤ 5000.1 ≤ Di ≤ 5000.1 ≤ Ts ≤ 5000.1 ≤ Tf ≤ 5000.Large dataset 2 ≤ N ≤ 2000.1 ≤ Si ≤ 109.1 ≤ Fi ≤ 109.1 ≤ Di ≤ 109.1 ≤ Ts ≤ 109.1 ≤ Tf ≤ 109. Sample12345678910111213141516171819202122232425Input 44 3 123 2 16 2 21 3 23 2 301 2 273 2 14 1 112 1 24 1 58 2 25 10 500014 27 3127 11 4430 8 202000 4000 3OutputCase #1: 2Case #2: 0Case #3: IMPOSSIBLECase #4: 4 Solution","categories":[{"name":"Kickstart","slug":"Kickstart","permalink":"http://yoursite.com/categories/Kickstart/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"待月随笔","slug":"daiyuesuibi","date":"2017-07-20T01:54:07.987Z","updated":"2017-07-20T01:54:08.189Z","comments":true,"path":"2017/07/20/daiyuesuibi/","link":"","permalink":"http://yoursite.com/2017/07/20/daiyuesuibi/","excerpt":"","text":"","categories":[{"name":"广播剧","slug":"广播剧","permalink":"http://yoursite.com/categories/广播剧/"}],"tags":[{"name":"个人YY","slug":"个人YY","permalink":"http://yoursite.com/tags/个人YY/"}]},{"title":"POJ 3258 River Hopscotch","slug":"poj_3258","date":"2017-07-19T17:12:07.315Z","updated":"2017-07-18T02:39:20.408Z","comments":true,"path":"2017/07/20/poj_3258/","link":"","permalink":"http://yoursite.com/2017/07/20/poj_3258/","excerpt":"","text":"题意POJ 3258: River Hopscotch从N块石头中移除M块，使得间距最小值最大。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;//const int INF = 1000000010;int n, l, m;int d[50010];bool C(int x) &#123; int last = 0; for (int i = 1; i &lt; n - m; i++) &#123; int cur = last + 1; while (cur &lt; n &amp;&amp; d[cur] - d[last] &lt; x) &#123; cur++; &#125; if (cur == n )return false; last = cur; &#125; return true;&#125;void solve() &#123; sort(d, d + n ); int lb = 0, ub = l + 1; while (ub - lb &gt; 1) &#123; int mid = lb + ((ub - lb) &gt;&gt; 1); if (C(mid)) lb = mid; else ub = mid; //cout &lt;&lt; \"lb= \" &lt;&lt; lb &lt;&lt; \" ub=\" &lt;&lt; ub &lt;&lt; endl; &#125; cout &lt;&lt; lb &lt;&lt; endl;&#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); cin &gt;&gt; l &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; d[0] = 0; //起点 d[n + 1] = l; //终点 n++; n++; solve();&#125;","categories":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/categories/POJ/"}],"tags":[{"name":"最大化最小值","slug":"最大化最小值","permalink":"http://yoursite.com/tags/最大化最小值/"},{"name":"二分法","slug":"二分法","permalink":"http://yoursite.com/tags/二分法/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]}]}