{"meta":{"title":"Alison's Space","subtitle":null,"description":null,"author":"Alison","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2017-07-20T06:32:03.728Z","updated":"2017-07-18T01:38:18.584Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-07-20T06:32:03.732Z","updated":"2017-07-18T01:38:18.583Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-08-18T12:23:37.985Z","updated":"2017-08-18T12:23:37.985Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我是个程序员"}],"posts":[{"title":"人脸变形常用方法","slug":"image_warp_1","date":"2017-11-02T05:53:11.636Z","updated":"2017-11-02T06:58:14.692Z","comments":true,"path":"2017/11/02/image_warp_1/","link":"","permalink":"http://yoursite.com/2017/11/02/image_warp_1/","excerpt":"","text":"实验室接的项目，客户是某大型婚纱摄影公司。要求把刚拍好的婚纱照尽量美化，节省百分之八十的美工工作。我负责人脸变形部分，调整脸型和五官。调研一番后，发现很多APP都已经实现了实时瘦脸和大眼两个功能，用的算法就两种，调整形状用图像局部扭曲算法，放大用图像局部放大算法。 图像局部扭曲算法 图像局部扭曲其实就是PS中的“液化”效果，又称为前倾变形。 这种变形算法我参考了这篇博客 但是其中只给了简要的步骤，并没有讲明具体的插值办法，所以自己用双线性插值法写了个完整的算法，主要插值代码如下： 1234567891011121314151617181920212223242526272829 for j = Top : Bottom for i = Left : Right dy = j - Cy; dx = i - Cx; PC2 = dx * dx + dy * dy; if PC2 &lt;= r2 k=(r2-PC2)/(r2-PC2+MC2); k2=k*k; x=i-k2*MCx; y=j-k2*MCy; x=max(x,1); x=min(x,w-1); y=max(y,1); y=min(y,h-1); x1=floor(x); x2=x1+1; y1=floor(y); y2=y1+1; tt1=(x2-x)*J(y1,x1,:)+(x-x1)*J(y1,x2,:); tt2=(x2-x)*J(y2,x1,:)+(x-x1)*J(y2,x2,:); tt=(y2-y)*tt1+(y-y1)*tt2; J(j,i,:)=tt; end endend 图像局部放大算法","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://yoursite.com/categories/图像处理/"}],"tags":[]},{"title":"二叉搜索树的后序遍历序列","slug":"jzoffer_18","date":"2017-08-18T12:33:33.030Z","updated":"2017-08-19T14:10:08.601Z","comments":true,"path":"2017/08/18/jzoffer_18/","link":"","permalink":"http://yoursite.com/2017/08/18/jzoffer_18/","excerpt":"","text":"题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 题解参考牛客网答案BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。 Solution123456789101112131415161718public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length==0)return false; return check(sequence,0,sequence.length-1); &#125; boolean check(int [] s,int l,int r)&#123; if(l&gt;=r)return true; int i=r; while(i&gt;l &amp;&amp; s[i-1]&gt;s[r])i--; for(int j=i-1;j&gt;=l;j--)&#123; if(s[j]&gt;s[r]) return false; &#125; return check(s,l,i-1) &amp;&amp; check(s,i,r-1); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"TreeNode","slug":"TreeNode","permalink":"http://yoursite.com/tags/TreeNode/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"二叉树的镜像","slug":"jzoffer_17","date":"2017-08-18T12:25:52.553Z","updated":"2017-08-18T12:33:21.783Z","comments":true,"path":"2017/08/18/jzoffer_17/","link":"","permalink":"http://yoursite.com/2017/08/18/jzoffer_17/","excerpt":"","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:二叉树的镜像定义：源二叉树1234567891011 8 / \\ 6 10 / \\ / \\5 7 9 11镜像二叉树 8 / \\ 10 6 / \\ / \\11 9 7 5 Solution1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null)return; TreeNode tmp=root.left; root.left=root.right; root.right=tmp; Mirror(root.left); Mirror(root.right); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"TreeNode","slug":"TreeNode","permalink":"http://yoursite.com/tags/TreeNode/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"HasSubtree","slug":"jzoffer_16","date":"2017-08-18T12:24:16.644Z","updated":"2017-08-18T12:32:44.973Z","comments":true,"path":"2017/08/18/jzoffer_16/","link":"","permalink":"http://yoursite.com/2017/08/18/jzoffer_16/","excerpt":"","text":"题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） Solution1234567891011121314public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root1==null || root2==null)return false; return isEqual(root1,root2)||HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2); &#125; public boolean isEqual(TreeNode r1,TreeNode r2)&#123; if(r2==null)return true; if(r1==null)return false; return r1.val==r2.val &amp;&amp; isEqual(r1.left,r2.left) &amp;&amp; isEqual(r1.right,r2.right); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"TreeNode","slug":"TreeNode","permalink":"http://yoursite.com/tags/TreeNode/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"花花使用总结","slug":"honor_2","date":"2017-08-02T07:44:58.289Z","updated":"2017-08-02T08:09:14.794Z","comments":true,"path":"2017/08/02/honor_2/","link":"","permalink":"http://yoursite.com/2017/08/02/honor_2/","excerpt":"","text":"上单 反红开局不点技能，蹲草丛，36’左右去敌红，如果顺利，点2技能扔红，不顺利一技能逃跑。 gank不要急着收小兵，利用地方兵线作为跳板， 轻剑1技能贴近，平A加2技能打出沉默，逃跑的话，再1技能追上，切大招推人 打野我发现打野gank成功率比上单高 重剑连招轻剑3转重剑——A——2——1——A——1","categories":[{"name":"农药","slug":"农药","permalink":"http://yoursite.com/categories/农药/"}],"tags":[{"name":"花木兰","slug":"花木兰","permalink":"http://yoursite.com/tags/花木兰/"}]},{"title":"反转链表","slug":"jzoffer_15","date":"2017-07-21T08:23:05.883Z","updated":"2017-08-18T12:24:05.801Z","comments":true,"path":"2017/07/21/jzoffer_15/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_15/","excerpt":"","text":"Recursion12345678910public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null || head.next==null)return head; ListNode pre=ReverseList(head.next); head.next.next=head; head.next=null; return pre; &#125;&#125; Iterationwhile里面就做一件事，把所有向右的箭头全部变成向左123456789101112131415161718public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null || head.next==null)return head; ListNode rHead=null,cur=head,pre=null; while(cur.next!=null)&#123; ListNode tmp=cur.next; cur.next=pre; pre=cur; cur=tmp; &#125; rHead=cur; cur.next=pre; return rHead; &#125;&#125;`","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"},{"name":"reverse","slug":"reverse","permalink":"http://yoursite.com/tags/reverse/"}]},{"title":"链表中倒数第k个结点","slug":"jzoffer_14","date":"2017-07-21T06:59:53.682Z","updated":"2017-08-02T08:07:11.806Z","comments":true,"path":"2017/07/21/jzoffer_14/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_14/","excerpt":"","text":"题目描述输入一个链表，输出该链表中倒数第k个结点。 分析双指针，fast,slow Solution12345678910111213141516171819public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode fast=head,slow=head; while(k&gt;0 &amp;&amp; fast!=null)&#123; fast=fast.next; k--; &#125; if(k&gt;0)return null; while(fast!=null)&#123; fast=fast.next; slow=slow.next; &#125; return slow; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://yoursite.com/tags/two-pointers/"}]},{"title":"调整数组顺序使奇数位于偶数前面","slug":"jzoffer_13","date":"2017-07-21T06:57:22.827Z","updated":"2017-08-02T08:07:16.885Z","comments":true,"path":"2017/07/21/jzoffer_13/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_13/","excerpt":"","text":"题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 分析 首先会想到双指针遇到奇数偶数就交换，即quick-sort，但是会改变相对位置 然后想到冒泡排序，依次把偶数排到后面去，要n平方的时间复杂度，舍弃。 最后发现其实啥算法都不用，如下： 1234567891011121314151617181920import java.util.*;public class Solution &#123; public void reOrderArray(int [] array) &#123; Stack s=new Stack(); for(int i:array)&#123; if(i%2&gt;0)&#123; s.push(i); &#125; &#125; for(int i:array)&#123; if(i%2==0)&#123; s.push(i); &#125; &#125; for(int i=array.length-1;i&gt;=0;i--)&#123; array[i]=(int)s.pop(); &#125; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"数值的整数次方","slug":"jzoffer_12","date":"2017-07-21T06:36:43.709Z","updated":"2017-08-02T08:07:19.351Z","comments":true,"path":"2017/07/21/jzoffer_12/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_12/","excerpt":"","text":"题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 分析原理同快速幂运算 Solution123456789101112public class Solution &#123; public double Power(double base, int exponent) &#123; int e=Math.abs(exponent); double r=1; while(e&gt;0)&#123; if((e&amp;1)&gt;0)r*=base; base*=base; e&gt;&gt;=1; &#125; return (exponent&gt;=0)?r:1/r; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"bit manipulation","slug":"bit-manipulation","permalink":"http://yoursite.com/tags/bit-manipulation/"}]},{"title":"二进制中1的个数","slug":"jzoffer_11","date":"2017-07-21T06:03:49.215Z","updated":"2017-08-02T08:07:22.209Z","comments":true,"path":"2017/07/21/jzoffer_11/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_11/","excerpt":"","text":"题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示 分析n&amp;(n-1)可以去掉最右的1，不停地去掉1，直至为0 Solution12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int cnt=0; while(n!=0)&#123; n&amp;=n-1; //remove rightmost 1 cnt++; &#125; return cnt; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"bit manipulation","slug":"bit-manipulation","permalink":"http://yoursite.com/tags/bit-manipulation/"}]},{"title":"矩形覆盖","slug":"jzoffer_10","date":"2017-07-21T05:53:41.883Z","updated":"2017-08-02T08:06:54.207Z","comments":true,"path":"2017/07/21/jzoffer_10/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_10/","excerpt":"","text":"题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 分析看到这种“多少种方法”，要么是用backtracking来穷举，要么是用dp。拒绝穷举，于是思考dp。首先因为长方形是2X1的，所以不管怎么摆，一个4x4的格子只可能有2种摆法，一个2X1格子只可能有1种摆法。考虑第n行，要么是先摆好n-1，然后最后横着放个2*1，要么是先摆好n-2，然后竖着放两个2*1所以有 dp[i]=dp[i-1]+dp[i-2] Soltion123456789101112public class Solution &#123; public int RectCover(int target) &#123; if(target&lt;=2)return target; int p1=1,p2=2; while(target--&gt;2)&#123; int cur=p1+p2; p1=p2; p2=cur; &#125; return p2; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"变态跳台阶","slug":"jzoffer_9","date":"2017-07-21T02:52:53.244Z","updated":"2017-08-31T06:00:43.351Z","comments":true,"path":"2017/07/21/jzoffer_9/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_9/","excerpt":"","text":"题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 分析最BF的方法肯定是dp,对每个dp[i],将i之前所有的dp[j]累加,这样复杂度为n平方,想都不用想肯定TLE了然而仔细一想由dp[i]=∑dp[j](j&lt;i)，直接得到dp[i]=2*dp[i-1]，于是复杂度降为n Solution123456789101112131415public class Solution &#123; public int JumpFloorII(int target) &#123; int n=target; int[] dp=new int[n+1]; for(int i=0;i&lt;=n;i++)&#123; if(i&lt;=2)&#123; dp[i]=i; continue; &#125; dp[i]=dp[i-1]*2; &#125; return dp[n]; &#125;&#125; 进一步节省空间，去掉dp数组1234567891011public class Solution &#123; public int JumpFloorII(int target) &#123; int n=target; if(target&lt;=2)return target; int p=2; while(target--&gt;2)&#123; p*=2; &#125; return p; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"跳台阶","slug":"jzoffer_8","date":"2017-07-21T02:36:38.770Z","updated":"2017-08-31T06:00:03.746Z","comments":true,"path":"2017/07/21/jzoffer_8/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_8/","excerpt":"","text":"题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 Solution123456789101112public class Solution &#123; public int JumpFloor(int target) &#123; if(target&lt;=2)return target; int p1=1,p2=2; while(target--&gt;2)&#123; int cur=p1+p2; p1=p2; p2=cur; &#125; return p2; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"斐波那契数列","slug":"jzoffer_7","date":"2017-07-21T02:24:53.906Z","updated":"2017-08-02T08:06:36.433Z","comments":true,"path":"2017/07/21/jzoffer_7/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_7/","excerpt":"","text":"题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 分析 递归不好，n超大的时候溢出 用节省空间版dp Solution123456789101112public class Solution &#123; public int Fibonacci(int n) &#123; int pre1=0,pre2=1; if(n&lt;=1)return n; while(n--&gt;=2)&#123; int tmp=pre2; pre2=pre1+pre2; pre1=tmp; &#125; return pre2; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"recursion","slug":"recursion","permalink":"http://yoursite.com/tags/recursion/"}]},{"title":"旋转数组的最小数字","slug":"jzoffer_6","date":"2017-07-21T02:13:28.539Z","updated":"2017-08-02T08:06:25.066Z","comments":true,"path":"2017/07/21/jzoffer_6/","link":"","permalink":"http://yoursite.com/2017/07/21/jzoffer_6/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 Find Minimum in Rotated Sorted Array II(Hard,有重复数字) Solution12345678910111213141516import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int l=0,r=array.length-1; while(l&lt;r)&#123; int mid=l+((r-l)&gt;&gt;1); if(array[mid]&lt;array[r]) r=mid; else if(array[mid]&gt;array[r]) l=mid+1; else r--; &#125; return array[l]; &#125;&#125; 相关 Find Minimum in Rotated Sorted Array(无重复数字)12345678910111213public class Solution &#123; public int findMin(int[] nums) &#123; int l=0,r=nums.length-1; while(l&lt;r)&#123; int mid=(l+r)/2; if(nums[mid]&gt;nums[r]) l=mid+1; else r=mid; &#125; return nums[l]; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"},{"name":"rotate array","slug":"rotate-array","permalink":"http://yoursite.com/tags/rotate-array/"},{"name":"binary search","slug":"binary-search","permalink":"http://yoursite.com/tags/binary-search/"}]},{"title":"用两个栈实现队列","slug":"jzoffer_5","date":"2017-07-20T09:00:38.590Z","updated":"2017-08-02T08:06:26.011Z","comments":true,"path":"2017/07/20/jzoffer_5/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_5/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。LC:232. Implement Queue using Stacks 思路s2用来顺序存放所有元素，s1用来缓存每次存入新的node时，先将s2中的元素倒出到s1，即变为逆序了，然后再把新node压入s2，然后再把s1中的元素倒入s2 Solution123456789101112131415161718192021import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; while(!stack2.isEmpty())&#123; stack1.push(stack2.pop()); &#125; stack2.push(node);//或者stack1.push(node)，想想为啥 while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; public int pop() &#123; return stack2.pop(); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"queue","slug":"queue","permalink":"http://yoursite.com/tags/queue/"}]},{"title":"重建二叉树","slug":"jzoffer_4","date":"2017-07-20T08:45:12.987Z","updated":"2017-08-02T08:06:26.760Z","comments":true,"path":"2017/07/20/jzoffer_4/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_4/","excerpt":"","text":"题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。其实就是 LC105.Construct Binary Tree from Preorder and Inorder Traversal Solution1234567891011121314151617181920212223public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return build(pre,0,pre.length-1,in,0,in.length-1); &#125; TreeNode build(int [] pre,int ps,int pe,int [] in,int is ,int ie)&#123; if(ps&gt;pe||is&gt;ie || pe&gt;=pre.length || ie&gt;=in.length)return null; int r=0;//index of root in in[] //find root for(int i=is;i&lt;=ie;i++)&#123; if(in[i]==pre[ps])&#123; r=i; break; &#125; &#125; int d=r-is;// length of left part TreeNode root=new TreeNode(in[r]); root.left=build(pre,ps+1,ps+d,in,is,r-1); root.right=build(pre,ps+d+1,pe,in,r+1,ie); return root; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://yoursite.com/tags/tree/"},{"name":"binary tree","slug":"binary-tree","permalink":"http://yoursite.com/tags/binary-tree/"}]},{"title":"从尾到头打印链表","slug":"jzoffer_3","date":"2017-07-20T08:10:45.669Z","updated":"2017-08-02T08:06:27.984Z","comments":true,"path":"2017/07/20/jzoffer_3/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_3/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 Solution 1 Stack1234567891011121314151617import java.util.*;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack s=new Stack(); ListNode cur=listNode; while(cur!=null)&#123; s.push(cur.val); cur=cur.next; &#125; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); while(!s.isEmpty())&#123; res.add((int)s.pop()); &#125; return res; &#125;&#125; Soluton 2 Recursion12345678910111213import java.util.*;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(listNode ==null)return res; ListNode p=listNode; if(p.next!= null) res=printListFromTailToHead(p.next); res.add(p.val); return res; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"}]},{"title":"二维数组中的查找","slug":"jzoffer_1","date":"2017-07-20T07:35:22.877Z","updated":"2017-08-02T08:03:59.721Z","comments":true,"path":"2017/07/20/jzoffer_1/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_1/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 Solution123456789101112131415public class Solution &#123; public boolean Find(int target, int [][] a) &#123; if(a==null || a.length==0)return false; int m=a.length,n=a[0].length; int i=0,j=n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(a[i][j]==target)return true; else if(target&gt;a[i][j]) i++; else j--; &#125; return false; &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"search","slug":"search","permalink":"http://yoursite.com/tags/search/"}]},{"title":"IOS基础","slug":"ios_1","date":"2017-07-20T06:52:08.484Z","updated":"2017-07-20T06:52:09.139Z","comments":true,"path":"2017/07/20/ios_1/","link":"","permalink":"http://yoursite.com/2017/07/20/ios_1/","excerpt":"","text":"","categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/tags/IOS/"}]},{"title":"七月中旬随笔","slug":"honor_1","date":"2017-07-20T02:19:47.089Z","updated":"2017-07-20T02:19:47.127Z","comments":true,"path":"2017/07/20/honor_1/","link":"","permalink":"http://yoursite.com/2017/07/20/honor_1/","excerpt":"","text":"","categories":[{"name":"农药","slug":"农药","permalink":"http://yoursite.com/categories/农药/"}],"tags":[]},{"title":"10. Regular Expression Matching","slug":"LC_10","date":"2017-07-20T02:17:22.603Z","updated":"2017-07-20T05:19:05.293Z","comments":true,"path":"2017/07/20/LC_10/","link":"","permalink":"http://yoursite.com/2017/07/20/LC_10/","excerpt":"","text":"ProblemImplement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.​12345678910111213141516​'.' Matches any single character.'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(\"aa\",\"a\") → falseisMatch(\"aa\",\"aa\") → trueisMatch(\"aaa\",\"aa\") → falseisMatch(\"aa\", \"a*\") → trueisMatch(\"aa\", \".*\") → trueisMatch(\"ab\", \".*\") → trueisMatch(\"aab\", \"c*a*b\") → true My Solution1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int j = 2; j &lt;= n; j++) &#123; if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (p.charAt(j - 1) == '*') dp[i][j] = dp[i][j - 1] || (j &gt;= 2 &amp;&amp; dp[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) || (j &gt; 2 &amp;&amp; dp[i][j - 2]); else if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; return dp[m][n];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"替换空格","slug":"jzoffer_2","date":"2017-07-20T02:08:43.622Z","updated":"2017-08-02T08:04:07.431Z","comments":true,"path":"2017/07/20/jzoffer_2/","link":"","permalink":"http://yoursite.com/2017/07/20/jzoffer_2/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 Solution12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(\"\\\\s\",\"%20\"); &#125;&#125;","categories":[{"name":"剑指","slug":"剑指","permalink":"http://yoursite.com/categories/剑指/"}],"tags":[{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}]},{"title":"CNN初探","slug":"paper_1","date":"2017-07-20T02:05:23.411Z","updated":"2017-11-02T05:52:28.363Z","comments":true,"path":"2017/07/20/paper_1/","link":"","permalink":"http://yoursite.com/2017/07/20/paper_1/","excerpt":"","text":"","categories":[{"name":"图像理解","slug":"图像理解","permalink":"http://yoursite.com/categories/图像理解/"}],"tags":[]},{"title":"Round D Problem A. Go Sightseeing","slug":"kk_d_a","date":"2017-07-20T01:57:33.331Z","updated":"2017-07-20T02:24:11.595Z","comments":true,"path":"2017/07/20/kk_d_a/","link":"","permalink":"http://yoursite.com/2017/07/20/kk_d_a/","excerpt":"","text":"ProblemWhen you travel, you like to spend time sightseeing in as many cities as possible, but sometimes you might not be able to because you need to catch the bus to the next city. To maximize your travel enjoyment, you decide to write a program to optimize your schedule. You begin at city 1 at time 0 and plan to travel to cities 2 to N in ascending order, visiting every city. There is a bus service from every city i to the next city i + 1. The i-th bus service runs on a schedule that is specified by 3 integers: Si, Fi and Di, the start time, frequency and ride duration. Formally, this means that there is a bus leaving from city i at all times Si + xFi, where x is an integer and x ≥ 0, and the bus takes Di time to reach city i + 1. At each city between 1 and N - 1, inclusive, you can decide to spend Ts time sightseeing before waiting for the next bus, or you can immediately wait for the next bus. You cannot go sightseeing multiple times in the same city. You may assume that boarding and leaving buses takes no time. You must arrive at city N by time Tf at the latest. (Note that you cannot go sightseeing in city N, even if you arrive early. There’s nothing to see there!) What is the maximum number of cities you can go sightseeing in? InputThe input starts with one line containing one integer T, which is the number of test cases. T test cases follow. Each test case begins with a line containing 3 integers, N, Ts and Tf, representing the number of cities, the time taken for sightseeing in any city, and the latest time you can arrive in city N. This is followed by N - 1 lines. On the i-th line, there are 3 integers, Si, Fi and Di, indicating the start time, frequency, and duration of buses travelling from city i to city i + 1. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of cities you can go sightseeing in such that you can still arrive at city N by time Tf at the latest. If it is impossible to arrive at city N by time Tf, output Case #x: IMPOSSIBLE. Limits1 ≤ T ≤ 100.Small dataset 2 ≤ N ≤ 16.1 ≤ Si ≤ 5000.1 ≤ Fi ≤ 5000.1 ≤ Di ≤ 5000.1 ≤ Ts ≤ 5000.1 ≤ Tf ≤ 5000.Large dataset 2 ≤ N ≤ 2000.1 ≤ Si ≤ 109.1 ≤ Fi ≤ 109.1 ≤ Di ≤ 109.1 ≤ Ts ≤ 109.1 ≤ Tf ≤ 109. Sample12345678910111213141516171819202122232425Input 44 3 123 2 16 2 21 3 23 2 301 2 273 2 14 1 112 1 24 1 58 2 25 10 500014 27 3127 11 4430 8 202000 4000 3OutputCase #1: 2Case #2: 0Case #3: IMPOSSIBLECase #4: 4 Solution","categories":[{"name":"Kickstart","slug":"Kickstart","permalink":"http://yoursite.com/categories/Kickstart/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"待月随笔","slug":"daiyuesuibi","date":"2017-07-20T01:54:07.987Z","updated":"2017-07-20T01:54:08.189Z","comments":true,"path":"2017/07/20/daiyuesuibi/","link":"","permalink":"http://yoursite.com/2017/07/20/daiyuesuibi/","excerpt":"","text":"","categories":[{"name":"广播剧","slug":"广播剧","permalink":"http://yoursite.com/categories/广播剧/"}],"tags":[{"name":"个人YY","slug":"个人YY","permalink":"http://yoursite.com/tags/个人YY/"}]},{"title":"POJ 3258 River Hopscotch","slug":"poj_3258","date":"2017-07-19T17:12:07.315Z","updated":"2017-07-18T02:39:20.408Z","comments":true,"path":"2017/07/20/poj_3258/","link":"","permalink":"http://yoursite.com/2017/07/20/poj_3258/","excerpt":"","text":"题意POJ 3258: River Hopscotch从N块石头中移除M块，使得间距最小值最大。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;//const int INF = 1000000010;int n, l, m;int d[50010];bool C(int x) &#123; int last = 0; for (int i = 1; i &lt; n - m; i++) &#123; int cur = last + 1; while (cur &lt; n &amp;&amp; d[cur] - d[last] &lt; x) &#123; cur++; &#125; if (cur == n )return false; last = cur; &#125; return true;&#125;void solve() &#123; sort(d, d + n ); int lb = 0, ub = l + 1; while (ub - lb &gt; 1) &#123; int mid = lb + ((ub - lb) &gt;&gt; 1); if (C(mid)) lb = mid; else ub = mid; //cout &lt;&lt; \"lb= \" &lt;&lt; lb &lt;&lt; \" ub=\" &lt;&lt; ub &lt;&lt; endl; &#125; cout &lt;&lt; lb &lt;&lt; endl;&#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); cin &gt;&gt; l &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; d[0] = 0; //起点 d[n + 1] = l; //终点 n++; n++; solve();&#125;","categories":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/categories/POJ/"}],"tags":[{"name":"最大化最小值","slug":"最大化最小值","permalink":"http://yoursite.com/tags/最大化最小值/"},{"name":"二分法","slug":"二分法","permalink":"http://yoursite.com/tags/二分法/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]}]}